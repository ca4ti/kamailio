--- a/modules/tm/h_table.h
+++ b/modules/tm/h_table.h
@@ -142,11 +142,12 @@ enum kill_reason { REQ_FWDED=1, REQ_RPLD
 
 typedef struct retr_buf
 {
-	short activ_type;
-	/* set to status code if the buffer is a reply,
-	0 if request or -1 if local CANCEL */
+	/* rbtype is set to status code if the buffer is a reply,
+	 * 0 (TYPE_REQUEST) if request, -1 if local CANCEL (TYPE_LOCAL_CANCEL),
+	 * -2 if local ACK (TYPE_LOCAL_ACK) */
+	short rbtype;
 	volatile unsigned short flags; /* DISABLED, T2 */
-	volatile unsigned char t_active; /* timer active */
+	volatile unsigned short t_active; /* timer active */
 	unsigned short branch; /* no more then 65k branches :-) */
 	int buffer_len;
 	char *buffer;
--- a/modules/tm/t_cancel.c
+++ b/modules/tm/t_cancel.c
@@ -318,7 +318,7 @@ int cancel_branch( struct cell *t, int b
 	crb->branch = branch;
 	/* label it as cancel so that FR timer can better know how to
 	   deal with it */
-	crb->activ_type = TYPE_LOCAL_CANCEL;
+	crb->rbtype = TYPE_LOCAL_CANCEL;
 	/* be extra carefully and check for bugs (the below if could be replaced
 	 *  by an atomic_set((void*)&crb->buffer, cancel) */
 	if (unlikely(atomic_cmpxchg_long((void*)&crb->buffer, (long)BUSY_BUFFER,
--- a/modules/tm/t_hooks.c
+++ b/modules/tm/t_hooks.c
@@ -300,7 +300,7 @@ void run_trans_callbacks_with_buf(int ty
 			((trans->tmcb_hl.reg_types)&type)==0 )
 		return;
 	INIT_TMCB_ONSEND_PARAMS(params, req, repl, rbuf, &rbuf->dst, rbuf->buffer,
-					rbuf->buffer_len, flags, rbuf->branch, rbuf->activ_type);
+					rbuf->buffer_len, flags, rbuf->branch, rbuf->rbtype);
 	/* req, rpl */
 	run_trans_callbacks_internal(&trans->tmcb_hl, type, trans, &params);
 }
--- a/modules/tm/t_reply.c
+++ b/modules/tm/t_reply.c
@@ -536,7 +536,7 @@ static int _reply_light( struct cell *tr
 	}
 
 	rb = & trans->uas.response;
-	rb->activ_type=code;
+	rb->rbtype=code;
 
 	trans->uas.status = code;
 	buf_len = rb->buffer ? len : len + REPLY_OVERBUFFER_LEN;
@@ -1784,7 +1784,7 @@ enum rps relay_reply( struct cell *t, st
 	uas_rb = & t->uas.response;
 	if (relay >= 0 ) {
 		/* initialize sockets for outbound reply */
-		uas_rb->activ_type=msg_status;
+		uas_rb->rbtype=msg_status;
 		/* only messages known to be relayed immediately will be
 		 * be called on; we do not evoke this callback on messages
 		 * stored in shmem -- they are fixed and one cannot change them
@@ -1801,7 +1801,7 @@ enum rps relay_reply( struct cell *t, st
 			if(t->flags & T_CANCELED) {
 				/* transaction canceled - send 487 */
 				relayed_code = 487;
-				uas_rb->activ_type = 487;
+				uas_rb->rbtype = 487;
 			} else {
 				relayed_code = (branch==relay)
 					? msg_status : t->uac[relay].last_received;
@@ -1856,7 +1856,7 @@ enum rps relay_reply( struct cell *t, st
 				buf=build_res_buf_from_sip_req(500, &reason,
 									to_tag, t->uas.request, &res_len, &bm);
 				relayed_code=500;
-				uas_rb->activ_type = 500;
+				uas_rb->rbtype = 500;
 			}else if (cfg_get(tm, tm_cfg, tm_aggregate_auth) && 
 						(relayed_code==401 || relayed_code==407) &&
 						(auth_reply_count(t, p_msg)>1)){
@@ -1968,13 +1968,13 @@ enum rps relay_reply( struct cell *t, st
 			if (SEND_PR_BUFFER( uas_rb, buf, res_len ) >= 0){
 				if (unlikely(!totag_retr && has_tran_tmcbs(t, TMCB_RESPONSE_OUT))){
 					LOCK_REPLIES( t );
-					if(relayed_code==uas_rb->activ_type) {
+					if(relayed_code==uas_rb->rbtype) {
 						run_trans_callbacks_with_buf( TMCB_RESPONSE_OUT, uas_rb, t->uas.request,
 												  relayed_msg, relayed_code);
 					} else {
 						DBG("DEBUG: skip tm callback %d - relay code %d active %d\n",
 							TMCB_RESPONSE_OUT, relayed_code,
-							uas_rb->activ_type);
+							uas_rb->rbtype);
 					}
 					UNLOCK_REPLIES( t );
 				}
--- a/modules/tm/timer.c
+++ b/modules/tm/timer.c
@@ -354,8 +354,8 @@ inline static ticks_t retransmission_han
 		abort();
 	}	
 #endif
-	if ( r_buf->activ_type==TYPE_LOCAL_CANCEL 
-		|| r_buf->activ_type==TYPE_REQUEST ) {
+	if ( r_buf->rbtype==TYPE_LOCAL_CANCEL
+		|| r_buf->rbtype==TYPE_REQUEST ) {
 #ifdef EXTRA_DEBUG
 			DBG("DEBUG: retransmission_handler : "
 				"request resending (t=%p, %.9s ... )\n", 
@@ -405,7 +405,7 @@ inline static void final_response_handle
 	}
 #	endif
 	/* FR for local cancels.... */
-	if (r_buf->activ_type==TYPE_LOCAL_CANCEL)
+	if (r_buf->rbtype==TYPE_LOCAL_CANCEL)
 	{
 #ifdef TIMER_DEBUG
 		DBG("DEBUG: final_response_handler: stop retr for Local Cancel\n");
@@ -413,7 +413,7 @@ inline static void final_response_handle
 		return;
 	}
 	/* FR for replies (negative INVITE replies) */
-	if (r_buf->activ_type>0) {
+	if (r_buf->rbtype>0) {
 #		ifdef EXTRA_DEBUG
 		if (t->uas.request->REQ_METHOD!=METHOD_INVITE
 			|| t->uas.status < 200 ) {
--- a/modules/tm/timer.h
+++ b/modules/tm/timer.h
@@ -205,7 +205,7 @@ inline static int _set_fr_retr(struct re
 #endif
 	/* adjust timeout to MIN(fr, maximum lifetime) if rb is a request
 	 *  (for neg. replies we are force to wait for the ACK so use fr) */
-	if (unlikely ((rb->activ_type==TYPE_REQUEST) && 
+	if (unlikely ((rb->rbtype==TYPE_REQUEST) &&
 		((s_ticks_t)(eol-(ticks+timeout))<0)) ){ /* fr after end of life */
 		timeout=(((s_ticks_t)(eol-ticks))>0)?(eol-ticks):1; /* expire now */ 
 	}
@@ -263,7 +263,7 @@ inline static void restart_rb_fr(struct
 	
 	now=get_ticks_raw();
 	t=rb->my_T;
-	if (unlikely ((rb->activ_type==TYPE_REQUEST) &&
+	if (unlikely ((rb->rbtype==TYPE_REQUEST) &&
 					(((s_ticks_t)(t->end_of_life-(now+new_val)))<0)) )
 		rb->fr_expire=t->end_of_life;
 	else
@@ -292,7 +292,7 @@ inline static void change_fr(struct cell
 				if ((t->uac[i].request.flags & F_RB_FR_INV) && fr_inv)
 					t->uac[i].request.fr_expire=fr_inv_expire;
 				else if (fr){
-					if (t->uac[i].request.activ_type==TYPE_REQUEST)
+					if (t->uac[i].request.rbtype==TYPE_REQUEST)
 						t->uac[i].request.fr_expire=req_fr_expire;
 					else
 						t->uac[i].request.fr_expire=fr_expire;
@@ -347,7 +347,7 @@ inline static void change_end_of_life(st
 	if (adj){
 		for (i=0; i<t->nr_of_outgoings; i++){
 			if (t->uac[i].request.t_active){ 
-					if ((t->uac[i].request.activ_type==TYPE_REQUEST) &&
+					if ((t->uac[i].request.rbtype==TYPE_REQUEST) &&
 							((s_ticks_t)(t->end_of_life - 
 										t->uac[i].request.fr_expire)<0))
 						t->uac[i].request.fr_expire=t->end_of_life;
--- a/modules/tm/uac.c
+++ b/modules/tm/uac.c
@@ -644,7 +644,7 @@ struct retr_buf *local_ack_rb(sip_msg_t
 	}
 
 	/* TODO: need next 2? */
-	lack->activ_type = TYPE_LOCAL_ACK;
+	lack->rbtype = TYPE_LOCAL_ACK;
 	lack->my_T = trans;
 
 	return lack;
