--- a/modules/tm/t_reply.c
+++ b/modules/tm/t_reply.c
@@ -1762,6 +1762,7 @@ enum rps relay_reply( struct cell *t, st
 	buf=0;
 	relayed_msg=0;
 	relayed_code=0;
+
 	totag_retr=0;
 
 	/* remember, what was sent upstream to know whether we are
@@ -1770,8 +1771,8 @@ enum rps relay_reply( struct cell *t, st
 	/* *** store and relay message as needed *** */
 	reply_status = t_should_relay_response(t, msg_status, branch,
 		&save_clone, &relay, cancel_data, p_msg );
-	DBG("DEBUG: relay_reply: branch=%d, save=%d, relay=%d icode=%d\n",
-		branch, save_clone, relay, t->uac[branch].icode);
+	DBG("DEBUG: relay_reply: branch=%d, save=%d, relay=%d icode=%d msg status=%u\n",
+		branch, save_clone, relay, t->uac[branch].icode, msg_status);
 
 	/* store the message if needed */
 	if (save_clone) /* save for later use, typically branch picking */
@@ -1800,8 +1801,9 @@ enum rps relay_reply( struct cell *t, st
 			if(t->flags & T_CANCELED) {
 				/* transaction canceled - send 487 */
 				relayed_code = 487;
+				uas_rb->activ_type = 487;
 			} else {
-				relayed_code = branch==relay
+				relayed_code = (branch==relay)
 					? msg_status : t->uac[relay].last_received;
 			}
 			/* use to_tag from the original request, or if not present,
@@ -1854,6 +1856,7 @@ enum rps relay_reply( struct cell *t, st
 				buf=build_res_buf_from_sip_req(500, &reason,
 									to_tag, t->uas.request, &res_len, &bm);
 				relayed_code=500;
+				uas_rb->activ_type = 500;
 			}else if (cfg_get(tm, tm_cfg, tm_aggregate_auth) && 
 						(relayed_code==401 || relayed_code==407) &&
 						(auth_reply_count(t, p_msg)>1)){
@@ -1968,6 +1971,10 @@ enum rps relay_reply( struct cell *t, st
 					if(relayed_code==uas_rb->activ_type) {
 						run_trans_callbacks_with_buf( TMCB_RESPONSE_OUT, uas_rb, t->uas.request,
 												  relayed_msg, relayed_code);
+					} else {
+						DBG("DEBUG: skip tm callback %d - relay code %d active %d\n",
+							TMCB_RESPONSE_OUT, relayed_code,
+							uas_rb->activ_type);
 					}
 					UNLOCK_REPLIES( t );
 				}
