From: Daniel-Constantin Mierla <miconda@gmail.com>
Date: Mon, 23 Mar 2020 18:42:23 +0100
Subject: [PATCH] rtpengine: replaced rtpproxy with rtpengine

- avoid confusion in printed log messges

(cherry picked from commit dda07c69420e1a38948dae4b71f8005b2375253b)
---
 src/modules/rtpengine/config.c       | 11 ++++++---
 src/modules/rtpengine/rtpengine.c    | 48 ++++++++++++++++++------------------
 src/modules/rtpengine/rtpengine.h    |  5 ++--
 src/modules/rtpengine/rtpengine_db.c |  4 +--
 4 files changed, 36 insertions(+), 32 deletions(-)

diff --git a/src/modules/rtpengine/config.c b/src/modules/rtpengine/config.c
index 946df8a..82cbffa 100644
--- a/src/modules/rtpengine/config.c
+++ b/src/modules/rtpengine/config.c
@@ -42,13 +42,16 @@ void	*rtpengine_cfg = &default_rtpengine_cfg;
 
 cfg_def_t	rtpengine_cfg_def[] = {
 	{"rtpengine_disable_tout",	CFG_VAR_INT | CFG_ATOMIC, 	0, 0, 0, 0,
-		"The time after which rtpengine will try to communicate to an RTP proxy after it has been marked disabled automatically. "},
+		"The time after which rtpengine module will try to communicate"
+			" with an RTPEngine instance after it has been marked disabled automatically. "},
 	{"aggressive_redetection",	CFG_VAR_INT | CFG_ATOMIC, 	0, 1, 0, 0,
-		"Determines if the sip proxy should force a query of all nodes when all RTP proxies seem unavailable."},
+		"Determines if the sip proxy should force a query of all nodes"
+			" when all RTPEngine instances seem unavailable."},
 	{"rtpengine_tout_ms",		CFG_VAR_INT | CFG_ATOMIC, 	0, 0, 0, 0,
-		"The total number of nodes inside a set to be queried before giving up establishing a session"},
+		"The total number of nodes inside a set to be queried before giving up"
+			" establishing a session"},
 	{"queried_nodes_limit",     CFG_VAR_INT | CFG_ATOMIC,   0, MAX_RTPP_TRIED_NODES, 0, 0,
-		"Timeout value expressed in milliseconds in waiting for reply from RTP proxy"},
+		"Timeout value expressed in milliseconds to wait for reply from RTPEngine"},
 	{"rtpengine_retr",	CFG_VAR_INT | CFG_ATOMIC,	0, 0, 0, 0,
 		"How many times the module should retry to send and receive after timeout was generated"},
 	{0, 0, 0, 0, 0, 0}
diff --git a/src/modules/rtpengine/rtpengine.c b/src/modules/rtpengine/rtpengine.c
index 135e34b..7be7968 100644
--- a/src/modules/rtpengine/rtpengine.c
+++ b/src/modules/rtpengine/rtpengine.c
@@ -257,7 +257,7 @@ static char ** rtpp_strings=0;
 static int rtpp_sets=0; /*used in rtpengine_set_store()*/
 static int rtpp_set_count = 0;
 static unsigned int current_msg_id = (unsigned int)-1;
-/* RTP proxy balancing list */
+/* RTPEngine balancing list */
 static struct rtpp_set_head * rtpp_set_list =0;
 static struct rtpp_set * active_rtpp_set =0;
 static struct rtpp_set * selected_rtpp_set_1 =0;
@@ -862,7 +862,7 @@ struct rtpp_set *get_rtpp_set(unsigned int set_id)
 		if(!rtpp_list)
 		{
 			lock_release(rtpp_set_list->rset_head_lock);
-			LM_ERR("no shm memory left to create new rtpproxy set %u\n", my_current_id);
+			LM_ERR("no shm memory left to create new rtpengine set %u\n", my_current_id);
 			return NULL;
 		}
 		memset(rtpp_list, 0, sizeof(struct rtpp_set));
@@ -870,14 +870,14 @@ struct rtpp_set *get_rtpp_set(unsigned int set_id)
 		rtpp_list->rset_lock = lock_alloc();
 		if (!rtpp_list->rset_lock) {
 			lock_release(rtpp_set_list->rset_head_lock);
-			LM_ERR("no shm memory left to create rtpproxy set lock\n");
+			LM_ERR("no shm memory left to create rtpengine set lock\n");
 			shm_free(rtpp_list);
 			rtpp_list = NULL;
 			return NULL;
 		}
 		if (lock_init(rtpp_list->rset_lock) == 0) {
 			lock_release(rtpp_set_list->rset_head_lock);
-			LM_ERR("could not init rtpproxy set lock\n");
+			LM_ERR("could not init rtpengine set lock\n");
 			lock_dealloc((void*)rtpp_list->rset_lock);
 			rtpp_list->rset_lock = NULL;
 			shm_free(rtpp_list);
@@ -915,17 +915,17 @@ struct rtpp_set *get_rtpp_set(unsigned int set_id)
 }
 
 
-int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy,
+int add_rtpengine_socks(struct rtpp_set *rtpp_list, char *rtpengine,
 			unsigned int weight, int disabled, unsigned int ticks, int isDB)
 {
-	/* Make rtp proxies list. */
+	/* Make rtpengine instances list. */
 	char *p, *p1, *p2, *plim;
 	struct rtpp_node *pnode;
 	struct rtpp_node *rtpp_node;
 	unsigned int local_weight, port;
 	str s1;
 
-	p = rtpproxy;
+	p = rtpengine;
 	plim = p + strlen(p);
 
 	for(;;) {
@@ -1100,7 +1100,7 @@ static int rtpengine_add_rtpengine_set(char * rtp_proxies, unsigned int weight,
 	rtp_proxies = strstr(p, "==");
 	if(rtp_proxies){
 		if(*(rtp_proxies +2)=='\0'){
-			LM_ERR("script error -invalid rtp proxy list!\n");
+			LM_ERR("script error -invalid rtpengine list!\n");
 			return -1;
 		}
 
@@ -1252,7 +1252,7 @@ static void rtpengine_rpc_reload(rpc_t* rpc, void* ctx)
 	}
 	_rtpe_list_version->vertime = tnow;
 
-	if (init_rtpproxy_db() < 0) {
+	if (init_rtpengine_db() < 0) {
 		// fail reloading from database
 		rpc->fault(ctx, 500, "Failed reloading db");
 		return;
@@ -1600,14 +1600,14 @@ mod_init(void)
 		}
 
 		if (lock_init(rtpp_set_list->rset_head_lock) == 0) {
-			LM_ERR("could not init rtpproxy list of proxysets lock\n");
+			LM_ERR("could not init lock sets for rtpengine list\n");
 			return -1;
 		}
 	}
 
 	if (rtpp_db_url.s == NULL)
 	{
-		/* storing the list of rtp proxy sets in shared memory*/
+		/* storing the list of rtpengine sets in shared memory*/
 		for(i=0;i<rtpp_sets;i++){
 			if(rtpengine_add_rtpengine_set(rtpp_strings[i], 1, 0, 0) !=0){
 				for(;i<rtpp_sets;i++)
@@ -1622,10 +1622,10 @@ mod_init(void)
 	}
 	else
 	{
-		LM_INFO("Loading rtp proxy definitions from DB\n");
-		if ( init_rtpproxy_db() < 0)
+		LM_INFO("Loading rtpengine definitions from DB\n");
+		if ( init_rtpengine_db() < 0)
 		{
-			LM_ERR("error while loading rtp proxies from database\n");
+			LM_ERR("error while loading rtpengine instances from database\n");
 			return -1;
 		}
 	}
@@ -1880,7 +1880,7 @@ static int build_rtpp_socks(int lmode, int rtest) {
 			}
 
 			if (connect(rtpp_socks[pnode->idx], res->ai_addr, res->ai_addrlen) == -1) {
-				LM_ERR("can't connect to a RTP proxy\n");
+				LM_ERR("can't connect to a RTPEngine instance\n");
 				close(rtpp_socks[pnode->idx]);
 				rtpp_socks[pnode->idx] = -1;
 				freeaddrinfo(res);
@@ -1968,7 +1968,7 @@ child_init(int rank)
 	}
 	memset(queried_nodes_ptr, 0, MAX_RTPP_TRIED_NODES * sizeof(struct rtpp_node*));
 
-	/* Iterate known RTP proxies - create sockets */
+	/* Iterate known RTPEngine instances - create sockets */
 	if(rank==PROC_SIPINIT) {
 		/* probe rtpengines only in first worker */
 		if (build_rtpp_socks(0, 1))
@@ -2782,7 +2782,7 @@ rtpp_test(struct rtpp_node *node, int isdisabled, int force)
 		goto error;
 	}
 
-	LM_INFO("rtp proxy <%s> found, support for it %senabled\n",
+	LM_INFO("rtpengine instance <%s> found, support for it %senabled\n",
 		node->rn_url.s, force == 0 ? "re-" : "");
 
 	bencode_buffer_free(&bencbuf);
@@ -2831,7 +2831,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 		}
 		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 			close(fd);
-			LM_ERR("can't connect to RTP proxy <%s>\n", node->rn_url.s);
+			LM_ERR("can't connect to RTPEngine <%s>\n", node->rn_url.s);
 			goto badproxy;
 		}
 
@@ -2840,7 +2840,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 		} while (len == -1 && errno == EINTR);
 		if (len <= 0) {
 			close(fd);
-			LM_ERR("can't send command to RTP proxy <%s>\n", node->rn_url.s);
+			LM_ERR("can't send command to RTPEngine <%s>\n", node->rn_url.s);
 			goto badproxy;
 		}
 		do {
@@ -2848,7 +2848,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 		} while (len == -1 && errno == EINTR);
 		close(fd);
 		if (len <= 0) {
-			LM_ERR("can't read reply from RTP proxy <%s>\n", node->rn_url.s);
+			LM_ERR("can't read reply from RTPEngine <%s>\n", node->rn_url.s);
 			goto badproxy;
 		}
 	} else {
@@ -2871,7 +2871,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 			} while (len == -1 && (errno == EINTR || errno == ENOBUFS));
 			if (len <= 0) {
 				bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
-				LM_ERR("can't send command \"%.*s\" to RTP proxy <%s>\n",
+				LM_ERR("can't send command \"%.*s\" to RTPEngine <%s>\n",
 					cmd.len, cmd.s, node->rn_url.s);
 				goto badproxy;
 			}
@@ -2883,7 +2883,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 				} while (len == -1 && errno == EINTR);
 				if (len <= 0) {
 					bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
-					LM_ERR("can't read reply for command \"%.*s\" from RTP proxy <%s>\n",
+					LM_ERR("can't read reply for command \"%.*s\" from RTPEngine <%s>\n",
 						cmd.len, cmd.s, node->rn_url.s);
 					goto badproxy;
 				}
@@ -2902,7 +2902,7 @@ send_rtpp_command(struct rtpp_node *node, bencode_item_t *dict, int *outlen)
 		}
 		if (i == rtpengine_retr) {
 			bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
-			LM_ERR("timeout waiting reply for command \"%.*s\" from RTP proxy <%s>\n",
+			LM_ERR("timeout waiting reply for command \"%.*s\" from RTPEngine <%s>\n",
 				cmd.len, cmd.s, node->rn_url.s);
 			goto badproxy;
 		}
@@ -3220,7 +3220,7 @@ set_rtpengine_set_from_avp(struct sip_msg *msg, int direction)
 
 	active_rtpp_set = select_rtpp_set(setid_val.n);
 	if(active_rtpp_set == NULL) {
-		LM_ERR("could not locate rtpproxy set %u\n", setid_val.n);
+		LM_ERR("could not locate engine set %u\n", setid_val.n);
 		return -1;
 	}
 
diff --git a/src/modules/rtpengine/rtpengine.h b/src/modules/rtpengine/rtpengine.h
index 354eceb..03999bf 100644
--- a/src/modules/rtpengine/rtpengine.h
+++ b/src/modules/rtpengine/rtpengine.h
@@ -86,14 +86,15 @@ struct rtpp_set_head {
 
 struct rtpp_node *get_rtpp_node(struct rtpp_set *rtpp_list, str *url);
 struct rtpp_set *get_rtpp_set(unsigned int set_id);
-int add_rtpengine_socks(struct rtpp_set * rtpp_list, char * rtpproxy, unsigned int weight, int disabled, unsigned int ticks, int isDB);
+int add_rtpengine_socks(struct rtpp_set *rtpp_list, char *rtpengine,
+		unsigned int weight, int disabled, unsigned int ticks, int isDB);
 
 int rtpengine_delete_node(struct rtpp_node *rtpp_node);
 int rtpengine_delete_node_set(struct rtpp_set *rtpp_list);
 int rtpengine_delete_node_all();
 
 
-int init_rtpproxy_db(void);
+int init_rtpengine_db(void);
 
 extern str rtpp_db_url;
 extern str rtpp_table_name;
diff --git a/src/modules/rtpengine/rtpengine_db.c b/src/modules/rtpengine/rtpengine_db.c
index 8532fd2..f83be25 100644
--- a/src/modules/rtpengine/rtpengine_db.c
+++ b/src/modules/rtpengine/rtpengine_db.c
@@ -97,7 +97,7 @@ static int rtpp_load_db(void)
 	rows = RES_ROWS(res);
 	if (n_rows == 0)
 	{
-		LM_WARN("No rtpproxy instances in database\n");
+		LM_WARN("No rtpengine instances in database\n");
 		rtpp_dbf.free_result(rtpp_db_handle, res);
 		return 0;
 	}
@@ -137,7 +137,7 @@ static int rtpp_load_db(void)
 	return 0;
 }
 
-int init_rtpproxy_db(void)
+int init_rtpengine_db(void)
 {
 	int ret;
 	if (rtpp_db_url.s == NULL)
